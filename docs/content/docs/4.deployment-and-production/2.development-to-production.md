---
title: Development to Production
description: 'Learn how to take your PHP application from development to production with confidence using Docker.'
layout: docs
---

::lead-p
The real power of Docker isn't just running containers locally — it's running the **exact same environment** from your laptop to production. This guide shows you how to achieve 100% environment replication and deploy with confidence.
::

## The traditional deployment problem
If you've deployed applications before, you've probably experienced these frustrations:

- **"It works on my machine"** - Something breaks in production that worked perfectly locally
- **Environment drift** - Your development, staging, and production environments slowly become different
- **Deployment anxiety** - Every deployment feels risky because you can't be sure what will happen
- **Vendor lock-in** - You're stuck with a PaaS provider because migrating is too painful
- **Downtime** - Users experience interruptions during deployments
- **Configuration chaos** - Infrastructure settings scattered across multiple places

These problems share a common root cause: **your environments aren't the same**.

## How Docker solves this
When you containerize your application properly, you package everything your app needs into a single, reproducible unit. This means:

### 100% environment replication
The container that runs on your MacBook is **identical** to the one running in production. Same PHP version, same extensions, same web server, same configurations. No surprises.

### Version-controlled infrastructure
Your `compose.yml` and Dockerfiles live in Git alongside your application code. Need to change PHP settings? Update a file, commit it, and deploy. Need to roll back? Just deploy the previous commit. Your infrastructure is now as manageable as your application code.

### Freedom to choose your host
Because your application is containerized, you can run it anywhere that supports Docker — DigitalOcean, Hetzner, Vultr, AWS, your own hardware, anywhere. If a host raises prices or doesn't meet your needs anymore, migration becomes straightforward instead of a massive project.

### Simplified scaling
Once you have one container running, scaling to multiple containers becomes much simpler. Add more resources by deploying more containers, not by re-configuring servers.

## The development to production journey
Let's walk through what this journey actually looks like when you use containers properly.

### 1. Development (where you are now)
You've already experienced this in our [installation guide](/docs/getting-started/installation). You're running containers locally with Docker Compose, your files are mounted as volumes, and changes appear instantly. This is perfect for development because:

- You can edit files with your favorite tools
- Changes appear immediately without rebuilding
- You can experiment freely
- Multiple developers work with identical environments

### 2. Building production images
For production, you'll create optimized images that have your application code **built into the image** instead of mounted as volumes. This ensures:

- Your code can't be accidentally modified in production
- Images are portable and can run anywhere
- Deployments are atomic — either the new version runs or the old one does
- You can roll back by deploying a previous image

We cover this in detail in our [packaging guide](/docs/deployment-and-production/packaging-your-app-for-deployment).

### 3. Choosing a deployment strategy
You have several options for running containers in production:

**Docker Compose** - Simple and effective for single-server deployments. Great for getting started.

**Docker Swarm** - Built into Docker, provides zero-downtime deployments, automatic SSL with Let's Encrypt, load balancing, and easy scaling across multiple servers.

**Kubernetes** - The most powerful option for large-scale deployments. More complex but extremely capable.

Each option uses the same OCI-compliant container images, so you can start simple and graduate to more sophisticated setups as you grow.

::tip
We recommend starting with Docker Compose for development environments and Docker Swarm for production. Swarm gives you zero-downtime deployments without the complexity of Kubernetes.
::

### 4. Automated deployments
The final piece is automation. Instead of manually SSHing into servers, you'll set up CI/CD pipelines (usually with GitHub Actions) that:

1. Run your tests on every commit
2. Build production images
3. Deploy automatically to staging or production
4. Roll back automatically if health checks fail

This means you can deploy with a simple `git push` and have confidence that your application will deploy safely.

## Simplifying the journey with Spin
While everything described above is achievable with standard Docker tools, there's a learning curve. We've experienced these challenges ourselves, which is why we created [Spin](https://serversideup.net/open-source/spin/).

::note
**Spin is NOT required** to use these Docker images. They work with any Docker setup. But if you're looking for a simpler path to production, Spin can help significantly.
::

### What is Spin?
Spin is a free and open source tool that simplifies Docker workflows from development to production. It helps you:

- Set up local development environments with a single command
- Provision and deploy to any VPS provider (DigitalOcean, Hetzner, Vultr, etc.)
- Configure Docker Swarm for zero-downtime deployments
- Set up automated SSL with Let's Encrypt
- Deploy with GitHub Actions
- Manage multiple environments (dev, staging, production)

Think of Spin as a helpful wrapper around Docker that handles the complex bits while teaching you Docker best practices.

### See it in action
This video demonstrates the complete journey from creating a Laravel project to deploying it to production with zero-downtime deployments:

:iframe{src="https://www.youtube-nocookie.com/embed/5z2JoEt5XIk?si=u5v-bDN-cMv0OE-C" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen style="aspect-ratio: 16/9; width: 100%;"}

The best part? It uses these same `serversideup/php` images you're already familiar with.

:u-button{to="https://serversideup.net/open-source/spin/" label="Learn more about Spin" aria-label="Learn more about Spin" target="_blank" size="md" color="primary" variant="outline" trailing-icon="i-lucide-arrow-right" class="font-bold ring ring-inset ring-blue-600 text-blue-600 hover:ring-blue-500 hover:text-blue-500"}

### Advanced Laravel features with Spin Pro
For teams running advanced Laravel features (Horizon, Reverb, scheduled tasks, multiple databases), we offer [Spin Pro](https://getspin.pro/) — a paid starter kit that includes pre-configured templates for these services.

It's a one-time purchase that gives you:
- Project templates with Horizon, Reverb, queues, and more
- Pre-configured GitHub Actions workflows
- Zero-downtime deployment configurations
- Support for multiple database engines (MySQL, PostgreSQL, MariaDB, SQLite)

Spin Pro exists because we've deployed dozens of Laravel applications ourselves and kept running into the same setup challenges. We built the solution we wished existed, and we're sharing it with the community.

::note
All Spin Pro templates use the same open source `serversideup/php` images and Spin CLI you're already using. You're buying the templates and automation, not proprietary technology.
::

## Alternative approaches
Spin is one tool among many. Here are other common approaches:

**Manual Docker Compose** - Use Docker Compose directly. More hands-on but gives you complete control. Great for learning.

**Kubernetes** - Use tools like Helm or Kustomize to deploy to Kubernetes clusters. More complex but extremely powerful for large-scale applications.

**PaaS Providers** - Services like Laravel Forge, Ploi, or platform providers can deploy containers for you. More expensive but less hands-on management.

**CI/CD Tools** - GitLab CI, GitHub Actions, or Jenkins can orchestrate your deployments without additional tools.

Choose whatever works best for your team's skills, budget, and requirements. The important part is that you're using containers, which means you maintain flexibility to change strategies later.

## Key principles for success
Regardless of which tools you choose, follow these principles:

1. **Keep development and production similar** - Use the same base images and configurations in both environments
2. **Store infrastructure in Git** - Version control your Docker configurations alongside your code
3. **Automate everything** - Manual deployments lead to mistakes and inconsistency
4. **Use health checks** - Let your orchestrator verify deployments succeed before switching traffic
5. **Practice deployments** - Deploy to staging frequently to catch issues before production
6. **Monitor your containers** - Use logging and monitoring to understand what's happening in production

## What's next?
Now that you understand the journey from development to production, you're ready to learn how to properly package your application for deployment.

:u-button{to="/docs/deployment-and-production/packaging-your-app-for-deployment" label="Learn how to package your app for deployment" aria-label="Learn how to package your app for deployment" size="md" color="primary" variant="outline" trailing-icon="i-lucide-arrow-right" class="font-bold ring ring-inset ring-blue-600 text-blue-600 hover:ring-blue-500 hover:text-blue-500"}